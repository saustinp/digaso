appname = 'streamer';
nd=2;

syms x1 x2  % Variables stored in the p vector
syms u1 u2 u3 u4 u5 u6 u7 u8 u9     % Components of UDG
syms time
syms param1 param2 param3 param4 param5 param6 param7 param8 param9 param10 param11    % Components of the physics parameters
syms nl1 nl2
syms uh1 uh2 uh3

pg = [x1 x2];
udg = [u1 u2 u3 u4 u5 u6 u7 u8 u9];
param = [param1 param2 param3 param4 param5 param6 param7 param8 param9 param10 param11];
nl = [nl1 nl2];    
uh = [uh1 uh2 uh3];

ncu = length(uh);
nc = length(udg);
nch = ncu;
                                       
% Read in values from the p vector
r_tilde = pg(1);
tau  = param(end);

% Read in values from the u vector
ne_tilde = udg(1);
ni_tilde = udg(2);
phi_tilde = udg(3);
dne_dr_tilde = udg(4);
dni_dr_tilde = udg(5);
Er_tilde = udg(6);
dne_dz_tilde = udg(7);
dni_dz_tilde = udg(8);
Ez_tilde = udg(9);

% Positivity enforcing
% alpha=100;
% ne_tilde = ne_tilde.*(atan(alpha*ne_tilde)/pi + 0.5) - atan(alpha)/pi + 0.5;
% ni_tilde = ni_tilde.*(atan(alpha*ni_tilde)/pi + 0.5) - atan(alpha)/pi + 0.5;

% Load physics param
l_ref = param(1);
mu_ref = param(2);
E_ref = param(3);
e_eps0 = param(4);
ne_star = param(10);

% Compute transport and source coefficients
normE_tilde = sqrt(Er_tilde^2 + Ez_tilde^2);
normE = normE_tilde*E_ref;

mue_tilde = (2.3987*normE^(-.26))/mu_ref;
De_tilde = 4.3628e-3*normE^.22 / (l_ref*mu_ref*E_ref);
alpha = (1.1944e6+ 4.3666e26/normE^3)*exp(-2.73e7/normE);
alpha_tile = alpha*l_ref;
eta_tilde = 340.75*l_ref;
alpha_bar_tilde = alpha_tile-eta_tilde;

mui_tilde = 2e-4 / mu_ref;
Di_tilde = 5e-5 / (l_ref*mu_ref*E_ref);     % Was 5e-6

% charge_prefactor_tilde = e_eps0/(E_ref*l_ref^2);
% av = 2e-3*ne_star*charge_prefactor_tilde*(ni_tilde - ne_tilde);    % Note sign flip in source term because the negative sign is absorbed in the diffusive flux in the LHS
% alpha = 1e2;
% av = av.*(atan(alpha*av)/pi + 0.5) - atan(alpha)/pi + 0.5;

% Flux
fv = [De_tilde.*dne_dr_tilde,  Di_tilde.*dni_dr_tilde  ,Er_tilde,...
      De_tilde.*dne_dz_tilde,  Di_tilde.*dni_dz_tilde  ,Ez_tilde];       % The negative sign is included in eqns 1 and 3 bc q=-grad(u)

fi = [-Er_tilde*mue_tilde*ne_tilde,  Er_tilde*mui_tilde*ni_tilde,0,...
      -Ez_tilde*mue_tilde*ne_tilde,  Ez_tilde*mui_tilde*ni_tilde,0];

f = r_tilde*(fi + fv);

% Fhat
% uh_tilde = uh(1).*(atan(alpha*uh(1))/pi + 0.5) - atan(alpha)/pi + 0.5;
uh_tilde = uh(1);
fhi = [-Er_tilde*mue_tilde*uh_tilde,0,0,...
       -Ez_tilde*mue_tilde*uh_tilde,0,0];
       
ff = r_tilde*(fhi + fv);

fhat = [simplify(ff(1)*nl(1) + ff(4)*nl(2) + tau*(udg(1)-uh(1))),...
        simplify(ff(2)*nl(1) + ff(5)*nl(2) + tau*(udg(2)-uh(2))),...
        simplify(ff(3)*nl(1) + ff(6)*nl(2) + tau*(phi_tilde-uh(3)))];

ff = (fhi + fv);
fhat = [simplify(ff(1)*nl(1) + ff(4)*nl(2) + tau*(udg(1)-uh(1))),...
        simplify(ff(2)*nl(1) + ff(5)*nl(2) + tau*(udg(2)-uh(2))),...
        simplify(ff(3)*nl(1) + ff(6)*nl(2) + tau*(phi_tilde-uh(3)))];
      
% Source
charge_prefactor_tilde = e_eps0/(E_ref*l_ref^2);
se = alpha_bar_tilde*mue_tilde*normE_tilde*ne_tilde;
sphi = ne_star*charge_prefactor_tilde*(ni_tilde - ne_tilde);    % Note sign flip in source term because the negative sign is absorbed in the diffusive flux in the LHS

s = r_tilde*[se se sphi];

% Log formulation
% eta_e = udg(1);
% eta_p = udg(2);
% phi_tilde = udg(3);
% detae_dr_tilde = udg(4);
% detai_dr_tilde = udg(5);
% Er_tilde = udg(6);
% deta_dz_tilde = udg(7);
% detai_dz_tilde = udg(8);
% Ez_tilde = udg(9);

% % grad_eta_e = [-detae_dr_tilde, -deta_dz_tilde];
% sphi = charge_prefactor_tilde*(exp(eta_p) - exp(eta_e));    % Note sign flip in source term because the negative sign is absorbed in the diffusive flux in the LHS
% se = alpha_bar_tilde*mue_tilde*normE_tilde + De_tilde*(detae_dr_tilde^2 + deta_dz_tilde^2) + (1-eta_e)*mue_tilde*sphi;
% sp = alpha_bar_tilde*mue_tilde*normE_tilde*exp(eta_e-eta_p);  % last term is ne/np = exp(eta_e)/exp(eta_p)
% s = r_tilde*[se sp sphi];

% filename1 = ['fluxG_' appname num2str(nd) 'd' '.c'];        % arbitrary letter "G" so that the original files aren't overwritten
% filename2 = ['sourceG_' appname num2str(nd) 'd'  '.c'];
% filename3 = ['fhatG_' appname num2str(nd) 'd' '.c'];

filename1 = ['fluxG' num2str(nd) 'd' '.c'];        % arbitrary letter "G" so that the original files aren't overwritten
filename2 = ['sourceG' num2str(nd) 'd'  '.c'];
filename3 = ['fbG' num2str(nd) 'd' '.c'];
%filename4 = ['fb' num2str(nd) 'd' '.c'];

genccode; % generate source codes

% filename1 = ['fluxonly_' appname num2str(nd) 'd' '.c'];
% filename2 = ['sourceonly_' appname num2str(nd) 'd'  '.c'];
% filename3 = ['fhatonly_' appname num2str(nd) 'd' '.c'];
% genccode_withoutjac; % generate source codes

% generate an application file
% gid = fopen('fluxes.c','w');
% fid = fopen('../../fluxes_template.c','r');    
% tline = fgetl(fid); 
% while ischar(tline)        
%     str = tline;
%     str = strrep(str, 'appname', appname);    
%     fprintf(gid, '%s\n', str);    
%     tline = fgetl(fid);            
% end
% fclose(fid);
% fclose(gid);